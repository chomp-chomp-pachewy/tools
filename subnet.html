<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CIDR & Subnet Calculator</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Roboto', sans-serif;
            background-color: #ffffff;
            color: #434343;
            line-height: 1.6;
        }
    
        nav {
            padding: 20px;
            text-align: right;
        }

        nav a {
            color: #999;
            text-decoration: none;
            margin-left: 30px;
            font-size: 0.95em;
        }

        nav a:hover {
            color: #333;
        }

        .header {
            background-color: #ffffff;
            padding: 30px 20px 20px 20px;
            text-align: center;
        }
        
        .header img {
            max-width: 300px;
            height: auto;
        }

        .container {
            max-width: 900px;
            margin: 40px auto;
            padding: 0 20px;
        }

        .section {
            margin-bottom: 60px;
        }

        .section-title {
            font-weight: 400;
            color: #666666;
            font-size: 1em;
            text-transform: lowercase;
            margin-bottom: 20px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 12px;
            font-weight: 400;
            color: #666666;
            font-size: 1em;
            text-transform: lowercase;
        }
        
        select, input[type="text"] {
            width: 100%;
            padding: 14px 16px;
            font-size: 15px;
            font-family: 'Roboto', sans-serif;
            border: 1px solid #434343;
            border-radius: 8px;
            background-color: #ffffff;
            color: #434343;
            transition: all 0.2s;
            text-transform: lowercase;
            height: 52px;
            box-sizing: border-box;
        }
       
        select:focus, input[type="text"]:focus {
            outline: none;
            border-color: #fe0032;
        }

        input[type="text"]::placeholder {
            color: #999;
        }

        .input-row {
            display: grid;
            grid-template-columns: 1fr 1fr auto;
            gap: 12px;
            margin-bottom: 20px;
        }

        .input-row-two {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 12px;
            margin-bottom: 20px;
        }

        .btn {
            padding: 14px 30px;
            font-size: 15px;
            font-family: 'Roboto', sans-serif;
            border: 1px solid #434343;
            border-radius: 8px;
            background-color: #ffffff;
            color: #434343;
            cursor: pointer;
            transition: all 0.2s;
            height: 52px;
            text-transform: lowercase;
            font-weight: 400;
            white-space: nowrap;
        }

        .btn:hover {
            background-color: #fe0032;
            border-color: #fe0032;
            color: #ffffff;
        }

        .results {
            margin-top: 40px;
        }

        .result-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }

        .result-box {
            background-color: #F2F2F4;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #434343;
        }

        .result-box-label {
            color: #666666;
            font-size: 0.85em;
            margin-bottom: 8px;
            font-weight: 400;
            text-transform: lowercase;
        }

        .result-box-value {
            color: #000000;
            font-size: 1em;
            font-weight: 400;
            font-family: monospace;
            word-break: break-all;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            justify-content: space-between;
        }

        .result-section {
            margin-bottom: 30px;
            background-color: #F2F2F4;
            padding: 30px;
            border-radius: 8px;
            border: 1px solid #434343;
        }

        .result-section h3 {
            color: #fe0032;
            font-size: 1em;
            margin-bottom: 20px;
            font-weight: 400;
            text-transform: lowercase;
        }

        .result-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid #ddd;
        }

        .result-item:last-child {
            border-bottom: none;
        }

        .result-label {
            color: #666666;
            font-weight: 400;
            text-transform: lowercase;
        }

        .result-value {
            font-weight: 400;
            color: #000000;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-family: monospace;
        }

        .copy-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 0.25rem;
            color: #666666;
            transition: color 0.2s;
            flex-shrink: 0;
        }

        .copy-btn:hover {
            color: #fe0032;
        }

        .error {
            color: #fe0032;
            padding: 15px;
            background-color: #fff0f0;
            border-radius: 8px;
            margin-top: 20px;
            font-size: 0.95em;
        }

        .toast {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            background-color: #434343;
            color: white;
            padding: 1rem 1.5rem;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            opacity: 0;
            transform: translateY(1rem);
            transition: opacity 0.3s, transform 0.3s;
            pointer-events: none;
            z-index: 1000;
        }

        .toast.show {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }

        .info-section {
            margin-top: 60px;
            padding: 30px;
            background-color: #F2F2F4;
            color: #000000;
            border-radius: 8px;
            border: 1px solid #434343;
            margin-bottom: 100px;
        }

        .info-section strong {
            color: #fe0032;
            font-weight: 400;
            display: block;
            margin-bottom: 10px;
            font-size: 1em;
            text-transform: lowercase;
        }

        .info-section p {
            margin: 0 0 15px 0;
            color: #000000;
            font-weight: 300;
            line-height: 1.8;
            font-size: 0.95em;
        }

        .info-section p:last-child {
            margin-bottom: 0;
        }

        .subnet-binary {
            font-family: monospace;
            font-size: 0.85em;
            color: #666666;
            margin-top: 0.25rem;
        }

        .divider {
            height: 1px;
            background-color: #e0e0e0;
            margin: 60px 0;
        }

        .clear-link {
            text-align: center;
            margin: 30px 0 20px 0;
        }

        .clear-link a {
            color: #fe0032;
            text-decoration: none;
            font-size: 0.95em;
            cursor: pointer;
            transition: opacity 0.2s;
            text-transform: lowercase;
        }

        .clear-link a:hover {
            opacity: 0.7;
        }

        @media (max-width: 768px) {
            .input-row {
                grid-template-columns: 1fr;
            }

            .input-row-two {
                grid-template-columns: 1fr;
            }

            .result-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <nav>
        <a href="https://chomp.ltd">home</a>
        <a href="https://tools.chomp.ltd">tools</a>
    </nav>

    <div class="header">
        <img src="https://raw.githubusercontent.com/chomp-chomp-pachewy/chomp-chomp/refs/heads/main/subnet.png" alt="Subnet Calculator">
    </div>

    <div class="container">
        <!-- Subnet Calculator Section -->
        <div class="section">
            <div class="section-title">subnet calculator</div>
            
            <div class="form-group">
                <label for="ipAddress">ip address / cidr</label>
                <div class="input-row">
                    <input type="text" id="ipAddress" placeholder="e.g., 192.168.1.0/24 or 192.168.1.0">
                    <select id="subnetMask">
                        <option value="">select mask (optional)</option>
                        <option value="32">/32 - 255.255.255.255</option>
                        <option value="31">/31 - 255.255.255.254</option>
                        <option value="30">/30 - 255.255.255.252</option>
                        <option value="29">/29 - 255.255.255.248</option>
                        <option value="28">/28 - 255.255.255.240</option>
                        <option value="27">/27 - 255.255.255.224</option>
                        <option value="26">/26 - 255.255.255.192</option>
                        <option value="25">/25 - 255.255.255.128</option>
                        <option value="24">/24 - 255.255.255.0</option>
                        <option value="23">/23 - 255.255.254.0</option>
                        <option value="22">/22 - 255.255.252.0</option>
                        <option value="21">/21 - 255.255.248.0</option>
                        <option value="20">/20 - 255.255.240.0</option>
                        <option value="19">/19 - 255.255.224.0</option>
                        <option value="18">/18 - 255.255.192.0</option>
                        <option value="17">/17 - 255.255.128.0</option>
                        <option value="16">/16 - 255.255.0.0</option>
                        <option value="15">/15 - 255.254.0.0</option>
                        <option value="14">/14 - 255.252.0.0</option>
                        <option value="13">/13 - 255.248.0.0</option>
                        <option value="12">/12 - 255.240.0.0</option>
                        <option value="11">/11 - 255.224.0.0</option>
                        <option value="10">/10 - 255.192.0.0</option>
                        <option value="9">/9 - 255.128.0.0</option>
                        <option value="8">/8 - 255.0.0.0</option>
                    </select>
                    <button class="btn" onclick="calcSubnet()">calculate</button>
                </div>
            </div>

            <div id="subnetError" class="error" style="display: none;"></div>
            
            <div id="subnetResults" class="results" style="display: none;"></div>

            <div class="clear-link">
                <a onclick="clearSubnet()">clear all values</a>
            </div>
        </div>

        <div class="divider"></div>

        <!-- CIDR Calculator Section -->
        <div class="section">
            <div class="section-title">cidr calculator</div>
            
            <div class="form-group">
                <label for="startIp">starting ip address</label>
                <input type="text" id="startIp" placeholder="e.g., 192.168.1.0">
            </div>

            <div class="form-group">
                <label for="endIp">ending ip address</label>
                <div class="input-row-two">
                    <input type="text" id="endIp" placeholder="e.g., 192.168.1.255">
                    <button class="btn" onclick="calcCIDR()">calculate</button>
                </div>
            </div>

            <div id="cidrError" class="error" style="display: none;"></div>
            
            <div id="cidrResults" class="results" style="display: none;"></div>

            <div class="clear-link">
                <a onclick="clearCIDR()">clear all values</a>
            </div>
        </div>

        <div class="info-section">
            <strong>about these calculators</strong>
            <p><strong>subnet calculator:</strong> takes a network address in CIDR notation (like 192.168.1.0/24) and calculates important network information including the network address, broadcast address, subnet mask, and the range of usable IP addresses. the prefix length determines how many IP addresses are in the subnet.</p>
            <p><strong>cidr calculator:</strong> converts IP address ranges to CIDR notation. CIDR (classless inter-domain routing) is a compact method for specifying IP address ranges. it consists of an IP address followed by a slash and a number (the prefix length), such as 192.168.1.0/24.</p>
        </div>
    </div>

    <div id="toast" class="toast"></div>

    <script>
        // Utility functions
        function ipToInt(ip) {
            const parts = ip.split('.').map(Number);
            return (parts[0] << 24) + (parts[1] << 16) + (parts[2] << 8) + parts[3];
        }

        function intToIp(int) {
            return [
                (int >>> 24) & 0xFF,
                (int >>> 16) & 0xFF,
                (int >>> 8) & 0xFF,
                int & 0xFF
            ].join('.');
        }

        function intToHex(int) {
            return [
                ((int >>> 24) & 0xFF).toString(16).toUpperCase().padStart(2, '0'),
                ((int >>> 16) & 0xFF).toString(16).toUpperCase().padStart(2, '0'),
                ((int >>> 8) & 0xFF).toString(16).toUpperCase().padStart(2, '0'),
                (int & 0xFF).toString(16).toUpperCase().padStart(2, '0')
            ].join('.');
        }

        function ipToBinary(ip) {
            const parts = ip.split('.');
            return parts.map(part => {
                return parseInt(part).toString(2).padStart(8, '0');
            }).join('.');
        }

        function isValidIp(ip) {
            const parts = ip.split('.');
            if (parts.length !== 4) return false;
            return parts.every(part => {
                const num = Number(part);
                return num >= 0 && num <= 255 && part === num.toString();
            });
        }

        function getNetworkClass(firstOctet) {
            if (firstOctet >= 1 && firstOctet <= 126) return 'A';
            if (firstOctet >= 128 && firstOctet <= 191) return 'B';
            if (firstOctet >= 192 && firstOctet <= 223) return 'C';
            if (firstOctet >= 224 && firstOctet <= 239) return 'D (multicast)';
            if (firstOctet >= 240 && firstOctet <= 255) return 'E (reserved)';
            return 'unknown';
        }

        function isPrivateIp(ip) {
            const parts = ip.split('.').map(Number);
            if (parts[0] === 10) return true;
            if (parts[0] === 172 && parts[1] >= 16 && parts[1] <= 31) return true;
            if (parts[0] === 192 && parts[1] === 168) return true;
            return false;
        }

        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).then(() => {
                showToast('copied to clipboard');
            }).catch(err => {
                showToast('failed to copy');
            });
        }

        function showToast(message) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => {
                toast.classList.remove('show');
            }, 2000);
        }

        // SUBNET CALCULATOR
        function calcSubnet() {
            const input = document.getElementById('ipAddress').value.trim();
            const maskSelect = document.getElementById('subnetMask').value;
            const errorDiv = document.getElementById('subnetError');
            const resultsDiv = document.getElementById('subnetResults');

            errorDiv.style.display = 'none';
            resultsDiv.style.display = 'none';

            let ip, prefix;
            if (input.includes('/')) {
                const parts = input.split('/');
                ip = parts[0];
                prefix = parseInt(parts[1]);
            } else {
                ip = input;
                if (maskSelect) {
                    prefix = parseInt(maskSelect);
                } else {
                    showSubnetError('please provide a CIDR prefix (e.g., /24) or select a subnet mask');
                    return;
                }
            }

            if (!isValidIp(ip)) {
                showSubnetError('invalid IP address');
                return;
            }

            if (isNaN(prefix) || prefix < 0 || prefix > 32) {
                showSubnetError('invalid CIDR prefix (must be between 0 and 32)');
                return;
            }

            const ipInt = ipToInt(ip);
            const maskInt = (0xFFFFFFFF << (32 - prefix)) >>> 0;
            const networkInt = (ipInt & maskInt) >>> 0;
            const broadcastInt = (networkInt | ~maskInt) >>> 0;
            
            const totalHosts = Math.pow(2, 32 - prefix);
            const usableHosts = prefix === 32 ? 1 : (prefix === 31 ? 2 : totalHosts - 2);
            
            const networkIp = intToIp(networkInt);
            const broadcastIp = intToIp(broadcastInt);
            const subnetMask = intToIp(maskInt);
            const wildcardMask = intToIp((~maskInt) >>> 0);
            
            const firstUsableIp = prefix === 32 ? networkIp : (prefix === 31 ? networkIp : intToIp(networkInt + 1));
            const lastUsableIp = prefix === 32 ? networkIp : (prefix === 31 ? broadcastIp : intToIp(broadcastInt - 1));
            
            const ipClass = getNetworkClass(parseInt(ip.split('.')[0]));
            const isPrivate = isPrivateIp(networkIp);

            const inputHex = intToHex(ipInt);
            const networkHex = intToHex(networkInt);
            const broadcastHex = intToHex(broadcastInt);
            const maskHex = intToHex(maskInt);

            displaySubnetResults({
                inputIp: ip,
                inputCidr: networkIp + '/' + prefix,
                inputLong: ipInt >>> 0,
                inputHex: inputHex,
                cidr: networkIp + '/' + prefix,
                cidrIpRange: networkIp + ' - ' + broadcastIp,
                cidrLongRange: (networkInt >>> 0) + ' - ' + (broadcastInt >>> 0),
                cidrHexRange: networkHex + ' - ' + broadcastHex,
                ipsInRange: totalHosts,
                maskBits: prefix,
                subnetMask: subnetMask,
                hexSubnetMask: maskHex,
                networkAddress: networkIp,
                broadcastAddress: broadcastIp,
                wildcardMask: wildcardMask,
                firstUsable: firstUsableIp,
                lastUsable: lastUsableIp,
                usableHosts: usableHosts,
                ipClass: ipClass,
                isPrivate: isPrivate,
                networkBinary: ipToBinary(networkIp),
                maskBinary: ipToBinary(subnetMask)
            });
        }

        function displaySubnetResults(data) {
            const resultsDiv = document.getElementById('subnetResults');
            
            let html = '<div class="result-grid">';
            html += createResultBox('input', data.inputCidr);
            html += createResultBox('input ip', data.inputIp);
            html += createResultBox('input long', data.inputLong);
            html += createResultBox('input hex', data.inputHex);
            html += '</div><div class="result-grid">';
            html += createResultBox('cidr', data.cidr);
            html += createResultBox('cidr ip range', data.cidrIpRange);
            html += createResultBox('cidr long range', data.cidrLongRange);
            html += createResultBox('cidr hex range', data.cidrHexRange);
            html += '</div><div class="result-grid">';
            html += createResultBox('ips in range', data.ipsInRange.toLocaleString());
            html += createResultBox('mask bits', data.maskBits);
            html += createResultBox('subnet mask', data.subnetMask);
            html += createResultBox('hex subnet mask', data.hexSubnetMask);
            html += '</div>';

            html += '<div class="result-section">';
            html += '<h3>network information</h3>';
            html += createResultItem('network address', data.networkAddress);
            html += createResultItem('broadcast address', data.broadcastAddress);
            html += createResultItem('wildcard mask', data.wildcardMask);
            html += '</div>';

            html += '<div class="result-section">';
            html += '<h3>usable ip range</h3>';
            html += createResultItem('first usable ip', data.firstUsable);
            html += createResultItem('last usable ip', data.lastUsable);
            html += createResultItem('usable ip addresses', data.usableHosts.toLocaleString(), false);
            html += '</div>';

            html += '<div class="result-section">';
            html += '<h3>additional information</h3>';
            html += createResultItem('ip class', data.ipClass, false);
            html += createResultItem('ip type', data.isPrivate ? 'private' : 'public', false);
            html += '<div class="result-item" style="flex-direction: column; align-items: flex-start;">';
            html += '<span class="result-label">binary subnet mask</span>';
            html += '<span class="subnet-binary">' + data.maskBinary + '</span>';
            html += '</div>';
            html += '<div class="result-item" style="flex-direction: column; align-items: flex-start;">';
            html += '<span class="result-label">network address (binary)</span>';
            html += '<span class="subnet-binary">' + data.networkBinary + '</span>';
            html += '</div>';
            html += '</div>';

            resultsDiv.innerHTML = html;
            resultsDiv.style.display = 'block';
        }

        function createResultBox(label, value) {
            let html = '<div class="result-box">';
            html += '<div class="result-box-label">' + label + '</div>';
            html += '<div class="result-box-value">';
            html += '<span>' + value + '</span>';
            html += '<button class="copy-btn" onclick="copyToClipboard(\'' + String(value).replace(/'/g, "\\'") + '\')" title="copy to clipboard">';
            html += '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">';
            html += '<rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>';
            html += '<path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>';
            html += '</svg></button>';
            html += '</div></div>';
            return html;
        }

        function createResultItem(label, value, showCopy = true) {
            let html = '<div class="result-item">';
            html += '<span class="result-label">' + label + '</span>';
            html += '<span class="result-value">' + value;
            if (showCopy) {
                html += '<button class="copy-btn" onclick="copyToClipboard(\'' + value + '\')" title="copy to clipboard">';
                html += '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">';
                html += '<rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>';
                html += '<path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>';
                html += '</svg></button>';
            }
            html += '</span></div>';
            return html;
        }

        function showSubnetError(message) {
            const errorDiv = document.getElementById('subnetError');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }

        function clearSubnet() {
            document.getElementById('ipAddress').value = '';
            document.getElementById('subnetMask').value = '';
            document.getElementById('subnetError').style.display = 'none';
            document.getElementById('subnetResults').style.display = 'none';
        }

       // CIDR CALCULATOR
function calcCIDR() {
    const startIp = document.getElementById('startIp').value.trim();
    const endIp = document.getElementById('endIp').value.trim();
    const errorDiv = document.getElementById('cidrError');
    const resultsDiv = document.getElementById('cidrResults');

    errorDiv.style.display = 'none';
    resultsDiv.style.display = 'none';

    if (!isValidIp(startIp)) {
        showCIDRError('invalid starting IP address');
        return;
    }
    if (!isValidIp(endIp)) {
        showCIDRError('invalid ending IP address');
        return;
    }

    const startInt = ipToInt(startIp);
    const endInt = ipToInt(endIp);

    if (startInt > endInt) {
        showCIDRError('starting IP must be less than or equal to ending IP');
        return;
    }

    const cidrBlocks = calculateCIDRBlocks(startInt, endInt);

    if (cidrBlocks.length === 0) {
        // This case should not be hit with valid IPs, but acts as a safeguard
        showCIDRError('unable to calculate CIDR notation for this range');
        return;
    }

    displayCIDRResults(cidrBlocks, endInt - startInt + 1);
}

function calculateCIDRBlocks(start, end) {
    const blocks = [];
    let current = start;

    // Use BigInt for intermediate size calculations to prevent overflow/imprecision, 
    // although standard bitwise operations should suffice if we stick to the 32-bit integer range.

    while (current <= end) {
        let prefix = 32;
        const diff = end - current + 1; // Remaining IP addresses in the target range

        // 1. Find the ideal prefix based on alignment.
        // We find the smallest prefix (largest power of 2) that the 'current' address is aligned to.
        for (let p = 32; p >= 0; p--) {
            // Create a bitmask for the host portion (32-p bits)
            const hostBits = 32 - p;
            
            // Check if the host portion of 'current' is all zeros (network boundary check)
            // (current & host_mask_int) === 0
            if ((current & ((1 << hostBits) - 1)) === 0 || hostBits === 32) {
                prefix = p;
                break; 
            }
        }

        // 2. Adjust prefix for range constraint (diff).
        // Find the smallest prefix (largest block) that is less than or equal to 'diff'.
        let maxPrefixForRange = 32;
        let largestPowerOfTwo = 1;

        for (let p = 31; p >= 0; p--) { // Start from p=31 (size 2)
            const blockSize = 1 << (32 - p);
            if (blockSize <= diff) {
                maxPrefixForRange = p;
                break;
            }
        }
        
        // Handle the /32 and /31 cases explicitly if needed, but the loop covers it.
        if (diff === 1) maxPrefixForRange = 32;
        if (diff === 2 && maxPrefixForRange > 31) maxPrefixForRange = 31;


        // The actual prefix is the smallest (longest mask) of the two constraints
        // We use Math.max because a LARGER prefix number means a SMALLER block size.
        prefix = Math.max(prefix, maxPrefixForRange); 
        
        // Calculate the resulting block size using the determined prefix
        const blockSize = Math.pow(2, 32 - prefix);

        blocks.push({
            network: intToIp(current),
            prefix: prefix,
            size: blockSize
        });

        current += blockSize;
    }

    return blocks;
}


function displayCIDRResults(cidrBlocks, totalIps) {
    // ... (This function remains the same as in your original code)
    const resultsDiv = document.getElementById('cidrResults');
    
    let html = '<div class="result-section">';
    html += '<h3>cidr results</h3>';
    html += '<div class="result-item">';
    html += '<span class="result-label">total ip addresses</span>';
    html += '<span class="result-value">' + totalIps.toLocaleString() + '</span>';
    html += '</div>';
    html += '<div class="result-item">';
    html += '<span class="result-label">number of cidr blocks</span>';
    html += '<span class="result-value">' + cidrBlocks.length + '</span>';
    html += '</div>';
    html += '<div class="result-item" style="flex-direction: column; align-items: flex-start; padding: 1rem 0;">';
    html += '<span class="result-label" style="margin-bottom: 0.75rem;">cidr notation</span>';
    
    cidrBlocks.forEach((block) => {
        const cidr = block.network + '/' + block.prefix;
        html += '<div style="display: flex; justify-content: space-between; width: 100%; margin-bottom: 0.5rem;">';
        html += '<span class="result-value" style="font-family: monospace;">' + cidr + '</span>';
        html += '<button class="copy-btn" onclick="copyToClipboard(\'' + cidr + '\')" title="copy to clipboard">';
        html += '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">';
        html += '<rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>';
        html += '<path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>';
        html += '</svg></button></div>';
    });
    
    html += '</div></div>';

    resultsDiv.innerHTML = html;
    resultsDiv.style.display = 'block';
}

function showCIDRError(message) {
    const errorDiv = document.getElementById('cidrError');
    errorDiv.textContent = message;
    errorDiv.style.display = 'block';
}

function clearCIDR() {
    document.getElementById('startIp').value = '';
    document.getElementById('endIp').value = '';
    document.getElementById('cidrError').style.display = 'none';
    document.getElementById('cidrResults').style.display = 'none';
}

        // Enter key support
        document.getElementById('ipAddress').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') calcSubnet();
        });
        document.getElementById('startIp').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') calcCIDR();
        });
        document.getElementById('endIp').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') calcCIDR();
        });
    </script>
</body>
</html>
