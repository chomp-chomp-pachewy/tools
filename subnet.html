<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CIDR & Subnet Calculator</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Roboto', sans-serif;
            background-color: #ffffff;
            color: #434343;
            line-height: 1.6;
        }
    
        nav {
            padding: 20px;
            text-align: right;
        }

        nav a {
            color: #999;
            text-decoration: none;
            margin-left: 30px;
            font-size: 0.95em;
        }

        nav a:hover {
            color: #333;
        }

        .header {
            background-color: #ffffff;
            padding: 30px 20px 20px 20px;
            text-align: center;
        }
        
        .header img {
            max-width: 300px;
            height: auto;
        }

        .container {
            max-width: 900px;
            margin: 40px auto;
            padding: 0 20px;
        }

        .section {
            margin-bottom: 60px;
        }
        
    .section-title {
      color: #fe0032;
      font-size: 1.15em;
      font-weight: 700;
      margin-bottom: 15px;
      text-transform: lowercase;
    }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 12px;
            font-weight: 400;
            color: #666666;
            font-size: 1em;
            text-transform: lowercase;
        }
        
        select, input[type="text"] {
            width: 100%;
            padding: 14px 16px;
            font-size: 15px;
            font-family: 'Roboto', sans-serif;
            border: 1px solid #434343;
            border-radius: 8px;
            background-color: #ffffff;
            color: #434343;
            transition: all 0.2s;
            text-transform: lowercase;
            height: 52px;
            box-sizing: border-box;
        }
       
        select:focus, input[type="text"]:focus {
            outline: none;
            border-color: #fe0032;
        }

        input[type="text"]::placeholder {
            color: #999;
        }

        .input-row {
            display: grid;
            grid-template-columns: 1fr 1fr auto;
            gap: 12px;
            margin-bottom: 20px;
        }

        .input-row-two {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 12px;
            margin-bottom: 20px;
        }

        .btn {
            padding: 14px 30px;
            font-size: 15px;
            font-family: 'Roboto', sans-serif;
            border: 1px solid #434343;
            border-radius: 8px;
            background-color: #ffffff;
            color: #434343;
            cursor: pointer;
            transition: all 0.2s;
            height: 52px;
            text-transform: lowercase;
            font-weight: 400;
            white-space: nowrap;
        }

        .btn:hover {
            background-color: #fe0032;
            border-color: #fe0032;
            color: #ffffff;
        }

        .results {
            margin-top: 40px;
        }

        .result-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }

        .result-box {
            background-color: #F2F2F4;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #434343;
        }

        .result-box-label {
            color: #666666;
            font-size: 0.85em;
            margin-bottom: 8px;
            font-weight: 400;
            text-transform: lowercase;
        }

        .result-box-value {
            color: #000000;
            font-size: 1em;
            font-weight: 400;
            font-family: monospace;
            word-break: break-all;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            justify-content: space-between;
        }

        .result-section {
            margin-bottom: 30px;
            background-color: #F2F2F4;
            padding: 30px;
            border-radius: 8px;
            border: 1px solid #434343;
        }

        .result-section h3 {
            color: #fe0032;
            font-size: 1em;
            margin-bottom: 20px;
            font-weight: 400;
            text-transform: lowercase;
        }

        .result-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid #ddd;
        }

        .result-item:last-child {
            border-bottom: none;
        }

        .result-label {
            color: #666666;
            font-weight: 400;
            text-transform: lowercase;
        }

        .result-value {
            font-weight: 400;
            color: #000000;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-family: monospace;
        }

        .copy-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 0.25rem;
            color: #666666;
            transition: color 0.2s;
            flex-shrink: 0;
        }

        .copy-btn:hover {
            color: #fe0032;
        }

        .error {
            color: #fe0032;
            padding: 15px;
            background-color: #fff0f0;
            border-radius: 8px;
            margin-top: 20px;
            font-size: 0.95em;
        }

        .toast {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            background-color: #434343;
            color: white;
            padding: 1rem 1.5rem;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            opacity: 0;
            transform: translateY(1rem);
            transition: opacity 0.3s, transform 0.3s;
            pointer-events: none;
            z-index: 1000;
        }

        .toast.show {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }

        .info-section {
            margin-top: 40px;
            padding: 30px;
            background-color: #F2F2F4;
            color: #000000;
            border-radius: 8px;
            border: 1px solid #434343;
            margin-bottom: 100px;
        }

        .info-section strong {
            color: #fe0032;
            font-weight: 400;
            display: block;
            margin-bottom: 10px;
            font-size: 1em;
            text-transform: lowercase;
        }

        .info-section p {
            margin: 0 0 15px 0;
            color: #000000;
            font-weight: 300;
            line-height: 1.8;
            font-size: 0.95em;
        }

        .info-section p:last-child {
            margin-bottom: 0;
        }

        .subnet-binary {
            font-family: monospace;
            font-size: 0.85em;
            color: #666666;
            margin-top: 0.25rem;
        }

        .divider {
            height: 1px;
            background-color: #e0e0e0;
            margin: 60px 0;
        }

        .clear-link {
            text-align: center;
            margin: 30px 0 20px 0;
        }

        .clear-link a {
            color: #fe0032;
            text-decoration: none;
            font-size: 0.95em;
            cursor: pointer;
            transition: opacity 0.2s;
            text-transform: lowercase;
        }

        .clear-link a:hover {
            opacity: 0.7;
        }

        @media (max-width: 768px) {
            .input-row {
                grid-template-columns: 1fr;
            }

            .input-row-two {
                grid-template-columns: 1fr;
            }

            .result-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <nav>
        <a href="https://chomp.ltd">home</a>
        <a href="https://tools.chomp.ltd">tools</a>
    </nav>

    <div class="header">
        <img src="https://raw.githubusercontent.com/chomp-chomp-pachewy/chomp-chomp/refs/heads/main/subnet.png" alt="Subnet Calculator">
    </div>

    <div class="container">
        <!-- Subnet Calculator Section -->
        <div class="section">
            <div class="section-title">subnet calculator</div>
            
            <div class="form-group">
                <label for="ipAddress">ip address / cidr</label>
                <div class="input-row">
                    <input type="text" id="ipAddress" placeholder="e.g., 192.168.1.0/24 or 192.168.1.0">
                    <select id="subnetMask">
                        <option value="">select mask (optional)</option>
                        <option value="32">/32 - 255.255.255.255</option>
                        <option value="31">/31 - 255.255.255.254</option>
                        <option value="30">/30 - 255.255.255.252</option>
                        <option value="29">/29 - 255.255.255.248</option>
                        <option value="28">/28 - 255.255.255.240</option>
                        <option value="27">/27 - 255.255.255.224</option>
                        <option value="26">/26 - 255.255.255.192</option>
                        <option value="25">/25 - 255.255.255.128</option>
                        <option value="24">/24 - 255.255.255.0</option>
                        <option value="23">/23 - 255.255.254.0</option>
                        <option value="22">/22 - 255.255.252.0</option>
                        <option value="21">/21 - 255.255.248.0</option>
                        <option value="20">/20 - 255.255.240.0</option>
                        <option value="19">/19 - 255.255.224.0</option>
                        <option value="18">/18 - 255.255.192.0</option>
                        <option value="17">/17 - 255.255.128.0</option>
                        <option value="16">/16 - 255.255.0.0</option>
                        <option value="15">/15 - 255.254.0.0</option>
                        <option value="14">/14 - 255.252.0.0</option>
                        <option value="13">/13 - 255.248.0.0</option>
                        <option value="12">/12 - 255.240.0.0</option>
                        <option value="11">/11 - 255.224.0.0</option>
                        <option value="10">/10 - 255.192.0.0</option>
                        <option value="9">/9 - 255.128.0.0</option>
                        <option value="8">/8 - 255.0.0.0</option>
                    </select>
                    <button class="btn" onclick="calcSubnet()">calculate</button>
                </div>
            </div>

            <div id="subnetError" class="error" style="display: none;"></div>
            
            <div id="subnetResults" class="results" style="display: none;"></div>

<div class="input-row-two" id="copySubnetBtnContainer" style="display:none;">
  <button class="btn" id="copySubnetBtn" onclick="copyAllSubnetResults()">copy all results</button>
 <button class="btn" id="copySubnetBtn" onclick="downloadSubnetResults">download .txt</button>
</div>

            <div class="clear-link">
                <a onclick="clearSubnet()">clear all values</a>
            </div>
        </div>

        <div class="divider"></div>

<!-- CIDR Calculator -->
<section id="cidr-section" class="calc-section">
  <div class="section-title">CIDR Range Calculator</div>

  <div class="form-group">
    <label for="startIp">Start IP Address</label>
    <input type="text" id="startIp" placeholder="e.g., 192.168.0.0" />
  </div>

  <div class="form-group">
    <label for="endIp">End IP Address</label>
    <input type="text" id="endIp" placeholder="e.g., 192.168.0.255" /></div>

      <div><button class="btn" onclick="calcCIDR()">calculate</button></div>
      
  <!-- <div class="button-row">
    <button class="primary-btn" onclick="calcCIDR()">Calculate</button>
    <button class="clear-btn" onclick="clearCIDR()">Clear All Values</button>
  </div> -->

  <div id="cidrError" class="error-message" style="display:none;"></div>

  <div id="cidrResults" class="results-card" style="display:none;">
      <div id="cidrOutput">
  <div class="info-section" id="cidrInfoSection" style="display:none;">
    <strong>cidr results</strong>
    <p id="cidrInfoText"></p>
  </div>
</div>      
  </div>
 <div class="clear-link">
                <a onclick="clearCIDR()">clear all values</a>
            </div>
</section>

        <div class="info-section">
            <strong>about these calculators</strong>
            <p><strong>subnet calculator:</strong> takes a network address in CIDR notation (like 192.168.1.0/24) and calculates important network information including the network address, broadcast address, subnet mask, and the range of usable IP addresses. the prefix length determines how many IP addresses are in the subnet.</p>
            <p><strong>cidr calculator:</strong> converts IP address ranges to CIDR notation. CIDR (classless inter-domain routing) is a compact method for specifying IP address ranges. it consists of an IP address followed by a slash and a number (the prefix length), such as 192.168.1.0/24.</p>
        </div>
    </div>

    <div id="toast" class="toast"></div>

    <script>

// ===== Utility Functions =====

// IPv4
function ipToInt(ip) {
    const parts = ip.split('.').map(Number);
    return (parts[0] << 24) + (parts[1] << 16) + (parts[2] << 8) + parts[3];
}

function intToIp(int) {
    return [
        (int >>> 24) & 0xFF,
        (int >>> 16) & 0xFF,
        (int >>> 8) & 0xFF,
        int & 0xFF
    ].join('.');
}

function intToHex(int) {
    return [
        ((int >>> 24) & 0xFF).toString(16).toUpperCase().padStart(2, '0'),
        ((int >>> 16) & 0xFF).toString(16).toUpperCase().padStart(2, '0'),
        ((int >>> 8) & 0xFF).toString(16).toUpperCase().padStart(2, '0'),
        (int & 0xFF).toString(16).toUpperCase().padStart(2, '0')
    ].join('.');
}

function ipToBinary(ip) {
    return ip.split('.').map(part => parseInt(part).toString(2).padStart(8, '0')).join('.');
}

function isValidIPv4(ip) {
    const parts = ip.split('.');
    if (parts.length !== 4) return false;
    return parts.every(part => {
        const n = Number(part);
        return n >= 0 && n <= 255 && part === n.toString();
    });
}

function isPrivateIPv4(ip) {
    const parts = ip.split('.').map(Number);
    return (parts[0] === 10) ||
           (parts[0] === 172 && parts[1] >= 16 && parts[1] <= 31) ||
           (parts[0] === 192 && parts[1] === 168);
}

// IPv6
function isValidIPv6(ip) {
    const regex = /^([0-9a-fA-F]{1,4}:){1,7}[0-9a-fA-F]{1,4}$/;
    return regex.test(ip.replace(/::/, ':').replace(/(^:|:$)/g, ''));
}

function isPrivateIPv6(ip) {
    return ip.toLowerCase().startsWith('fd'); // Unique local addresses
}

// Expand IPv6 for calculations
function expandIPv6(ip) {
    if (!ip.includes('::')) return ip;
    const [left, right] = ip.split('::');
    const leftCount = left ? left.split(':').length : 0;
    const rightCount = right ? right.split(':').length : 0;
    const missing = 8 - (leftCount + rightCount);
    const fill = Array(missing).fill('0000').join(':');
    return [left, fill, right].filter(Boolean).join(':');
}

function ipv6ToBigInt(ip) {
    const expanded = expandIPv6(ip);
    return expanded.split(':').reduce((acc, part) => (acc << 16n) + BigInt(parseInt(part, 16)), 0n);
}

function bigIntToIPv6(num) {
    const parts = [];
    for (let i = 0; i < 8; i++) {
        parts.unshift((num & 0xFFFFn).toString(16));
        num >>= 16n;
    }
    return parts.join(':').replace(/(^|:)0(:0)+(:|$)/, '::'); // Simple zero-compression
}

// ===== Subnet Calculator =====
function calcSubnet() {
    const input = document.getElementById('ipAddress').value.trim();
    const maskSelect = document.getElementById('subnetMask').value;
    const errorDiv = document.getElementById('subnetError');
    const resultsDiv = document.getElementById('subnetResults');

    errorDiv.style.display = 'none';
    resultsDiv.style.display = 'none';

    let ip, prefix;
    if (input.includes('/')) {
        [ip, prefix] = input.split('/');
        prefix = parseInt(prefix);
    } else {
        ip = input;
        prefix = maskSelect ? parseInt(maskSelect) : null;
    }

    const isIPv6 = ip.includes(':');

    if (isIPv6) {
        if (!isValidIPv6(ip)) {
            showSubnetError('Invalid IPv6 address.');
            return;
        }
        if (prefix === null || prefix < 0 || prefix > 128) {
            showSubnetError('Invalid IPv6 prefix (0-128).');
            return;
        }

        const ipNum = ipv6ToBigInt(ip);
        const mask = (1n << BigInt(128 - prefix)) - 1n;
        const networkNum = ipNum & (~mask);
        const broadcastNum = ipNum | mask;

        const firstUsable = networkNum;
        const lastUsable = broadcastNum;

        displaySubnetResults({
            inputIp: ip,
            inputCidr: `${ip}/${prefix}`,
            cidr: `${ip}/${prefix}`,
            cidrIpRange: `${bigIntToIPv6(networkNum)} - ${bigIntToIPv6(broadcastNum)}`,
            ipsInRange: 2n ** BigInt(128 - prefix),
            networkAddress: bigIntToIPv6(networkNum),
            broadcastAddress: bigIntToIPv6(broadcastNum),
            firstUsable: bigIntToIPv6(firstUsable),
            lastUsable: bigIntToIPv6(lastUsable),
            usableHosts: 2n ** BigInt(128 - prefix),
            ipClass: 'N/A',
            isPrivate: isPrivateIPv6(ip),
            maskBinary: null,
            networkBinary: null
        });
    } else {
        if (!isValidIPv4(ip)) {
            showSubnetError('Invalid IPv4 address.');
            return;
        }
        if (prefix === null || prefix < 0 || prefix > 32) {
            showSubnetError('Invalid IPv4 prefix (0-32).');
            return;
        }

        const ipInt = ipToInt(ip);
        const maskInt = (0xFFFFFFFF << (32 - prefix)) >>> 0;
        const networkInt = (ipInt & maskInt) >>> 0;
        const broadcastInt = (networkInt | ~maskInt) >>> 0;

        const totalHosts = 2 ** (32 - prefix);
        const usableHosts = prefix === 32 ? 1 : (prefix === 31 ? 2 : totalHosts - 2);
        const networkIp = intToIp(networkInt);
        const broadcastIp = intToIp(broadcastInt);
        const subnetMask = intToIp(maskInt);
        const wildcardMask = intToIp((~maskInt) >>> 0);
        const firstUsableIp = prefix === 32 ? networkIp : (prefix === 31 ? networkIp : intToIp(networkInt + 1));
        const lastUsableIp = prefix === 32 ? networkIp : (prefix === 31 ? broadcastIp : intToIp(broadcastInt - 1));
        const ipClass = getNetworkClass(parseInt(ip.split('.')[0]));
        const isPrivate = isPrivateIPv4(networkIp);

        displaySubnetResults({
            inputIp: ip,
            inputCidr: networkIp + '/' + prefix,
            inputLong: ipInt >>> 0,
            inputHex: intToHex(ipInt),
            cidr: networkIp + '/' + prefix,
            cidrIpRange: networkIp + ' - ' + broadcastIp,
            cidrLongRange: (networkInt >>> 0) + ' - ' + (broadcastInt >>> 0),
            cidrHexRange: intToHex(networkInt) + ' - ' + intToHex(broadcastInt),
            ipsInRange: totalHosts,
            maskBits: prefix,
            subnetMask: subnetMask,
            hexSubnetMask: intToHex(maskInt),
            networkAddress: networkIp,
            broadcastAddress: broadcastIp,
            wildcardMask: wildcardMask,
            firstUsable: firstUsableIp,
            lastUsable: lastUsableIp,
            usableHosts: usableHosts,
            ipClass: ipClass,
            isPrivate: isPrivate,
            networkBinary: ipToBinary(networkIp),
            maskBinary: ipToBinary(subnetMask)
        });
    }

    document.getElementById('copySubnetBtnContainer').style.display = 'block';
}

// ===== Copy All Results (IPv4 + IPv6) =====
function copyAllSubnetResults() {
    const resultsDiv = document.getElementById('subnetResults');
    if (!resultsDiv || resultsDiv.style.display === 'none') {
        alert('No subnet results to copy.');
        return;
    }

    let output = 'Subnet Calculation Results\n';
    output += `Generated on: ${new Date().toLocaleString()}\n\n`;

    const items = resultsDiv.querySelectorAll('.result-box, .result-item');
    items.forEach(item => {
        const label = item.querySelector('.result-label, .result-box-label')?.innerText?.trim() || '';
        const value = item.querySelector('.result-value, .result-box-value span')?.innerText?.trim() || '';
        if (label && value) output += `${label}: ${value}\n`;
    });

    navigator.clipboard.writeText(output).then(() => showToast('All subnet results copied to clipboard.'))
        .catch(() => showToast('Unable to copy results.'));
}

// ===== Helper Functions =====
function showSubnetError(msg) { const e = document.getElementById('subnetError'); e.textContent = msg; e.style.display = 'block'; }
function showToast(msg) { const t = document.getElementById('toast'); t.textContent = msg; t.classList.add('show'); setTimeout(() => t.classList.remove('show'), 2000); }


        // SUBNET CALCULATOR
        function calcSubnet() {
            const input = document.getElementById('ipAddress').value.trim();
            const maskSelect = document.getElementById('subnetMask').value;
            const errorDiv = document.getElementById('subnetError');
            const resultsDiv = document.getElementById('subnetResults');

            errorDiv.style.display = 'none';
            resultsDiv.style.display = 'none';

            let ip, prefix;
            if (input.includes('/')) {
                const parts = input.split('/');
                ip = parts[0];
                prefix = parseInt(parts[1]);
            } else {
                ip = input;
                if (maskSelect) {
                    prefix = parseInt(maskSelect);
                } else {
                    showSubnetError('please provide a CIDR prefix (e.g., /24) or select a subnet mask');
                    return;
                }
            }

            if (!isValidIp(ip)) {
                showSubnetError('invalid IP address');
                return;
            }

            if (isNaN(prefix) || prefix < 0 || prefix > 32) {
                showSubnetError('invalid CIDR prefix (must be between 0 and 32)');
                return;
            }

            const ipInt = ipToInt(ip);
            const maskInt = (0xFFFFFFFF << (32 - prefix)) >>> 0;
            const networkInt = (ipInt & maskInt) >>> 0;
            const broadcastInt = (networkInt | ~maskInt) >>> 0;
            
            const totalHosts = Math.pow(2, 32 - prefix);
            const usableHosts = prefix === 32 ? 1 : (prefix === 31 ? 2 : totalHosts - 2);
            
            const networkIp = intToIp(networkInt);
            const broadcastIp = intToIp(broadcastInt);
            const subnetMask = intToIp(maskInt);
            const wildcardMask = intToIp((~maskInt) >>> 0);
            
            const firstUsableIp = prefix === 32 ? networkIp : (prefix === 31 ? networkIp : intToIp(networkInt + 1));
            const lastUsableIp = prefix === 32 ? networkIp : (prefix === 31 ? broadcastIp : intToIp(broadcastInt - 1));
            
            const ipClass = getNetworkClass(parseInt(ip.split('.')[0]));
            const isPrivate = isPrivateIp(networkIp);

            const inputHex = intToHex(ipInt);
            const networkHex = intToHex(networkInt);
            const broadcastHex = intToHex(broadcastInt);
            const maskHex = intToHex(maskInt);

            displaySubnetResults({
                inputIp: ip,
                inputCidr: networkIp + '/' + prefix,
                inputLong: ipInt >>> 0,
                inputHex: inputHex,
                cidr: networkIp + '/' + prefix,
                cidrIpRange: networkIp + ' - ' + broadcastIp,
                cidrLongRange: (networkInt >>> 0) + ' - ' + (broadcastInt >>> 0),
                cidrHexRange: networkHex + ' - ' + broadcastHex,
                ipsInRange: totalHosts,
                maskBits: prefix,
                subnetMask: subnetMask,
                hexSubnetMask: maskHex,
                networkAddress: networkIp,
                broadcastAddress: broadcastIp,
                wildcardMask: wildcardMask,
                firstUsable: firstUsableIp,
                lastUsable: lastUsableIp,
                usableHosts: usableHosts,
                ipClass: ipClass,
                isPrivate: isPrivate,
                networkBinary: ipToBinary(networkIp),
                maskBinary: ipToBinary(subnetMask)
            });
            document.getElementById('copySubnetBtnContainer').style.display = 'block';
        }

        function displaySubnetResults(data) {
            const resultsDiv = document.getElementById('subnetResults');
            
            let html = '<div class="result-grid">';
            html += createResultBox('input', data.inputCidr);
            html += createResultBox('input ip', data.inputIp);
            html += createResultBox('input long', data.inputLong);
            html += createResultBox('input hex', data.inputHex);
            html += '</div><div class="result-grid">';
            html += createResultBox('cidr', data.cidr);
            html += createResultBox('cidr ip range', data.cidrIpRange);
            html += createResultBox('cidr long range', data.cidrLongRange);
            html += createResultBox('cidr hex range', data.cidrHexRange);
            html += '</div><div class="result-grid">';
            html += createResultBox('ips in range', data.ipsInRange.toLocaleString());
            html += createResultBox('mask bits', data.maskBits);
            html += createResultBox('subnet mask', data.subnetMask);
            html += createResultBox('hex subnet mask', data.hexSubnetMask);
            html += '</div>';

            html += '<div class="result-section">';
            html += '<h3>network information</h3>';
            html += createResultItem('network address', data.networkAddress);
            html += createResultItem('broadcast address', data.broadcastAddress);
            html += createResultItem('wildcard mask', data.wildcardMask);
            html += '</div>';

            html += '<div class="result-section">';
            html += '<h3>usable ip range</h3>';
            html += createResultItem('first usable ip', data.firstUsable);
            html += createResultItem('last usable ip', data.lastUsable);
            html += createResultItem('usable ip addresses', data.usableHosts.toLocaleString(), false);
            html += '</div>';

            html += '<div class="result-section">';
            html += '<h3>additional information</h3>';
            html += createResultItem('ip class', data.ipClass, false);
            html += createResultItem('ip type', data.isPrivate ? 'private' : 'public', false);
            html += '<div class="result-item" style="flex-direction: column; align-items: flex-start;">';
            html += '<span class="result-label">binary subnet mask</span>';
            html += '<span class="subnet-binary">' + data.maskBinary + '</span>';
            html += '</div>';
            html += '<div class="result-item" style="flex-direction: column; align-items: flex-start;">';
            html += '<span class="result-label">network address (binary)</span>';
            html += '<span class="subnet-binary">' + data.networkBinary + '</span>';
            html += '</div>';
            html += '</div>';

            resultsDiv.innerHTML = html;
            resultsDiv.style.display = 'block';
        }

        function createResultBox(label, value) {
            let html = '<div class="result-box">';
            html += '<div class="result-box-label">' + label + '</div>';
            html += '<div class="result-box-value">';
            html += '<span>' + value + '</span>';
            html += '<button class="copy-btn" onclick="copyToClipboard(\'' + String(value).replace(/'/g, "\\'") + '\')" title="copy to clipboard">';
            html += '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">';
            html += '<rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>';
            html += '<path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>';
            html += '</svg></button>';
            html += '</div></div>';
            return html;
        }

        function createResultItem(label, value, showCopy = true) {
            let html = '<div class="result-item">';
            html += '<span class="result-label">' + label + '</span>';
            html += '<span class="result-value">' + value;
            if (showCopy) {
                html += '<button class="copy-btn" onclick="copyToClipboard(\'' + value + '\')" title="copy to clipboard">';
                html += '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">';
                html += '<rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>';
                html += '<path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>';
                html += '</svg></button>';
            }
            html += '</span></div>';
            return html;
        }

        function showSubnetError(message) {
            const errorDiv = document.getElementById('subnetError');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }

        function clearSubnet() {
            document.getElementById('ipAddress').value = '';
            document.getElementById('subnetMask').value = '';
            document.getElementById('subnetError').style.display = 'none';
            document.getElementById('subnetResults').style.display = 'none';
            document.getElementById('copySubnetBtnContainer').style.display = 'none';
        }

// ---- CIDR Calculator ---- //

function calcCIDR() {
  const startIp = document.getElementById('startIp').value.trim();
  const endIp = document.getElementById('endIp').value.trim();
  const errorDiv = document.getElementById('cidrError');
  const resultsDiv = document.getElementById('cidrResults');
  const outputDiv = document.getElementById('cidrOutput');

  errorDiv.style.display = 'none';
  resultsDiv.style.display = 'none';

  if (!validateIP(startIp) || !validateIP(endIp)) {
    showCIDRError('Please enter valid IPv4 addresses.');
    return;
  }

  const start = ipToLong(startIp);
  const end = ipToLong(endIp);

  if (end < start) {
    showCIDRError('End IP must be greater than or equal to Start IP.');
    return;
  }

  const blocks = calculateCIDRBlocks(start, end);
  
const infoSection = document.getElementById('cidrInfoSection');
const infoText = document.getElementById('cidrInfoText');

infoText.innerHTML = blocks.join('<br>');
infoSection.style.display = 'block';
    
  resultsDiv.style.display = 'block';
}

function calculateCIDRBlocks(start, end) {
  const result = [];
  while (end >= start) {
    // Largest power of two block that fits starting from 'start'
    let maxSize = 32;
    while (maxSize > 0) {
      const mask = 2 ** (32 - maxSize);
      if ((start & (mask - 1)) !== 0) break;
      maxSize--;
    }

    // Largest block that does not exceed the end IP
    const remaining = end - start + 1;
    while (2 ** (32 - maxSize) > remaining) maxSize++;

    result.push(longToIP(start) + '/' + maxSize);
    start += 2 ** (32 - maxSize);
  }
  return result;
}

function validateIP(ip) {
  const parts = ip.split('.');
  if (parts.length !== 4) return false;
  return parts.every(p => p >= 0 && p <= 255 && /^\d+$/.test(p));
}

function ipToLong(ip) {
  return ip.split('.').reduce((acc, oct) => (acc << 8) + parseInt(oct), 0) >>> 0;
}

function longToIP(long) {
  return [
    (long >>> 24) & 255,
    (long >>> 16) & 255,
    (long >>> 8) & 255,
    long & 255
  ].join('.');
}

function showCIDRError(message) {
  const errorDiv = document.getElementById('cidrError');
  errorDiv.textContent = message;
  errorDiv.style.display = 'block';
}

function clearCIDR() {
  document.getElementById('startIp').value = '';
  document.getElementById('endIp').value = '';
  document.getElementById('cidrError').style.display = 'none';
  document.getElementById('cidrResults').style.display = 'none';
}
        // Enter key support
        document.getElementById('ipAddress').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') calcSubnet();
        });
        document.getElementById('startIp').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') calcCIDR();
        });
        document.getElementById('endIp').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') calcCIDR();
        });

// === Shared text generator for both copy & download ===
function generateSubnetOutputText() {
    const resultsDiv = document.getElementById('subnetResults');
    if (!resultsDiv || resultsDiv.style.display === 'none') {
        return null;
    }

    let output = '';

    // Timestamp and CIDR summary
    const now = new Date();
    const timestamp = now.toLocaleString();

    const cidrItem = [...resultsDiv.querySelectorAll('.result-box, .result-item')]
        .find(el => el.innerText.includes('/') && el.innerText.match(/[\dA-Fa-f:.]+\/\d+/));
    const inputSummary = cidrItem
        ? (cidrItem.innerText.split(':')[1]?.trim() || cidrItem.innerText.trim())
        : '';

    const isIPv6 = inputSummary.includes(':');

    output += `Subnet Calculation Results\n`;
    output += `Generated on: ${timestamp}\n`;
    if (inputSummary) output += `Input: ${inputSummary}\n`;
    output += `Type: ${isIPv6 ? 'IPv6' : 'IPv4'}\n\n`;

    // Gather sections
    const sections = resultsDiv.querySelectorAll('.result-section, .result-grid');

    sections.forEach(section => {
        const header = section.querySelector('h3');
        if (header) {
            let title = header.innerText.trim();
            if (isIPv6 && title.toLowerCase().includes('network information')) {
                title = 'Network Prefix Information';
            } else if (isIPv6 && title.toLowerCase().includes('usable ip range')) {
                title = 'Assignable Address Range';
            }

            const line = '='.repeat(title.length);
            output += `${title.toUpperCase()}\n${line}\n`;
        }

        const items = section.querySelectorAll('.result-item, .result-box');
        items.forEach(item => {
            const label = item.querySelector('.result-label, .result-box-label')?.innerText?.trim() || '';
            const value = item.querySelector('.result-value, .result-box-value span')?.innerText?.trim() || '';
            if (label && value) {
                let adjustedLabel = label;
                if (isIPv6) {
                    if (label.toLowerCase().includes('network address')) adjustedLabel = 'network prefix';
                    if (label.toLowerCase().includes('broadcast')) adjustedLabel = 'last address in prefix';
                    if (label.toLowerCase().includes('subnet mask')) adjustedLabel = 'prefix length';
                    if (label.toLowerCase().includes('wildcard mask')) adjustedLabel = 'prefix mask (not used)';
                }
                output += `${adjustedLabel}: ${value}\n`;
            }
        });

        output += '\n';
    });

    if (/%[0-9A-F]{2}/i.test(output)) {
        try {
            output = decodeURIComponent(output);
        } catch {
            console.warn('Skipping decode â€” invalid URI encoding.');
        }
    }

    return output.trim() + '\n';
}

// === Copy to clipboard ===
function copyAllSubnetResults() {
    const output = generateSubnetOutputText();
    if (!output) {
        alert('No subnet results to copy.');
        return;
    }

    navigator.clipboard.writeText(output).then(() => {
        showToast('All subnet results copied to clipboard.');
    }).catch(err => {
        console.error('Copy failed', err);
        showToast('Unable to copy results.');
    });
}

// === Download as .txt file ===
function downloadSubnetResults() {
    const output = generateSubnetOutputText();
    if (!output) {
        alert('No subnet results to download.');
        return;
    }

    const blob = new Blob([output], { type: 'text/plain;charset=utf-8' });
    const url = URL.createObjectURL(blob);

    const a = document.createElement('a');
    const now = new Date();
    const timestamp = now.toISOString().replace(/[:.]/g, '-');
    a.href = url;
    a.download = `subnet-results-${timestamp}.txt`;
    a.click();

    URL.revokeObjectURL(url);
    showToast('Subnet results downloaded as text file.');
}

        
        
    </script>
</body>
</html>
