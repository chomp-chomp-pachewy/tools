<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>subnet calculator - chomp tools</title>
    
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
    
    <!-- Shared Chomp styles -->
    <link rel="stylesheet" href="chomp-shared.css">
    <!-- Tools-specific styles -->
    <link rel="stylesheet" href="tools.css">
    
    <style>
        .input-row {
            display: grid;
            grid-template-columns: 1fr 1fr auto;
            gap: 12px;
            margin-bottom: 20px;
        }
        .input-row-two {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 12px;
            margin-bottom: 20px;
        }
        .result-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }
        .result-box {
            background-color: var(--bg-secondary);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid var(--border-light);
        }
        .result-label {
            font-size: 0.85em;
            color: var(--text-secondary);
            margin-bottom: 8px;
            text-transform: lowercase;
        }
        .result-value {
            font-size: 1.1em;
            color: var(--text-primary);
            font-family: 'Courier New', monospace;
            word-break: break-all;
        }
        @media (max-width: 768px) {
            .input-row {
                grid-template-columns: 1fr;
            }
            .input-row-two {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <!-- Theme toggle -->
    <div class="theme-toggle" onclick="toggleTheme()"></div>
    
    <!-- Navigation -->
    <nav>
        <a href="https://tools.chomp.ltd">all tools</a>
    </nav>

    <div class="tool-page" style="max-width: 900px;">
        <div class="tool-header">
            <img src="https://raw.githubusercontent.com/chomp-chomp-pachewy/chomp-chomp/refs/heads/main/subnet.png" alt="subnet calculator" style="max-width: 300px; margin-bottom: 30px;">
        </div>

        <div class="section-title" style="color: var(--accent-red); font-size: 1.15em; font-weight: 700; margin: 30px 0 15px 0; text-transform: lowercase;">CIDR Calculator</div>
        
        <div class="tool-controls">
            <div class="control-group">
                <label class="control-label">IP Address & CIDR</label>
                <div class="input-row">
                    <input type="text" id="cidrIP" class="control-input" placeholder="e.g., 192.168.1.0">
                    <input type="text" id="cidrPrefix" class="control-input" placeholder="prefix (e.g., 24)">
                    <button class="tool-button" onclick="calculateCIDR()">calculate</button>
                </div>
            </div>
        </div>

        <div id="cidrResults" style="display: none;">
            <div class="result-grid" id="cidrResultGrid"></div>
        </div>

        <div class="section-title" style="color: var(--accent-red); font-size: 1.15em; font-weight: 700; margin: 40px 0 15px 0; text-transform: lowercase;">Subnet Calculator</div>
        
        <div class="tool-controls">
            <div class="control-group">
                <label class="control-label">IP Address</label>
                <input type="text" id="subnetIP" class="control-input" placeholder="e.g., 192.168.1.0">
            </div>

            <div class="control-group">
                <label class="control-label">Subnet Mask</label>
                <select id="subnetMask" class="tool-select">
                    <option value="255.255.255.0">/24 - 255.255.255.0</option>
                    <option value="255.255.255.128">/25 - 255.255.255.128</option>
                    <option value="255.255.255.192">/26 - 255.255.255.192</option>
                    <option value="255.255.255.224">/27 - 255.255.255.224</option>
                    <option value="255.255.255.240">/28 - 255.255.255.240</option>
                    <option value="255.255.255.248">/29 - 255.255.255.248</option>
                    <option value="255.255.255.252">/30 - 255.255.255.252</option>
                    <option value="255.255.254.0">/23 - 255.255.254.0</option>
                    <option value="255.255.252.0">/22 - 255.255.252.0</option>
                    <option value="255.255.248.0">/21 - 255.255.248.0</option>
                    <option value="255.255.240.0">/20 - 255.255.240.0</option>
                    <option value="255.255.224.0">/19 - 255.255.224.0</option>
                    <option value="255.255.192.0">/18 - 255.255.192.0</option>
                    <option value="255.255.128.0">/17 - 255.255.128.0</option>
                    <option value="255.255.0.0">/16 - 255.255.0.0</option>
                </select>
            </div>

            <div class="tool-actions">
                <button class="tool-button" onclick="calculateSubnet()">calculate</button>
            </div>
        </div>

        <div id="subnetResults" style="display: none;">
            <div class="result-grid" id="subnetResultGrid"></div>
        </div>

        <div class="section-title" style="color: var(--accent-red); font-size: 1.15em; font-weight: 700; margin: 40px 0 15px 0; text-transform: lowercase;">IP Range to CIDR</div>
        
        <div class="tool-controls">
            <div class="control-group">
                <label class="control-label">IP Range</label>
                <div class="input-row-two">
                    <input type="text" id="rangeStart" class="control-input" placeholder="start IP (e.g., 192.168.1.0)">
                    <button class="tool-button" onclick="rangeToCIDR()">convert</button>
                </div>
                <input type="text" id="rangeEnd" class="control-input" placeholder="end IP (e.g., 192.168.1.255)" style="margin-top: 12px;">
            </div>
        </div>

        <div id="rangeResults" style="display: none;">
            <div class="result-grid" id="rangeResultGrid"></div>
        </div>
    </div>

    <script>
            margin-bottom: 20px;
            font-weight: 400;
            text-transform: lowercase;
        }

        .result-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid #ddd;
        }

        .result-item:last-child {
            border-bottom: none;
        }

        .result-label {
            color: #666666;
            font-weight: 400;
            text-transform: lowercase;
        }

        .result-value {
            font-weight: 400;
            color: #000000;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-family: monospace;
        }

        .copy-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 0.25rem;
            color: #666666;
            transition: color 0.2s;
            flex-shrink: 0;
        }

        .copy-btn:hover {
            color: #fe0032;
        }

        .error {
            color: #fe0032;
            padding: 15px;
            background-color: #fff0f0;
            border-radius: 8px;
            margin-top: 20px;
            font-size: 0.95em;
        }

        .toast {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            background-color: #434343;
            color: white;
            padding: 1rem 1.5rem;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            opacity: 0;
            transform: translateY(1rem);
            transition: opacity 0.3s, transform 0.3s;
            pointer-events: none;
            z-index: 1000;
        }

        .toast.show {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }

        .info-section {
            margin-top: 40px;
            padding: 30px;
            background-color: #F2F2F4;
            color: #000000;
            border-radius: 8px;
            border: 1px solid #434343;
            margin-bottom: 100px;
        }

        .info-section strong {
            color: #fe0032;
            font-weight: 400;
            display: block;
            margin-bottom: 10px;
            font-size: 1em;
            text-transform: lowercase;
        }

        .info-section p {
            margin: 0 0 15px 0;
            color: #000000;
            font-weight: 300;
            line-height: 1.8;
            font-size: 0.95em;
        }

        .info-section p:last-child {
            margin-bottom: 0;
        }

        .subnet-binary {
            font-family: monospace;
            font-size: 0.85em;
            color: #666666;
            margin-top: 0.25rem;
        }

        .divider {
            height: 1px;
            background-color: #e0e0e0;
            margin: 60px 0;
        }

        .clear-link {
            text-align: center;
            margin: 30px 0 20px 0;
        }

        .clear-link a {
            color: #fe0032;
            text-decoration: none;
            font-size: 0.95em;
            cursor: pointer;
            transition: opacity 0.2s;
            text-transform: lowercase;
        }

        .clear-link a:hover {
            opacity: 0.7;
        }

        @media (max-width: 768px) {
            .input-row {
                grid-template-columns: 1fr;
            }

            .input-row-two {
                grid-template-columns: 1fr;
            }

            .result-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <nav>
        <a href="https://tools.chomp.ltd">all tools</a>
    </nav>

    <div class="header">
        <img src="https://raw.githubusercontent.com/chomp-chomp-pachewy/chomp-chomp/refs/heads/main/subnet.png" alt="Subnet Calculator">
    </div>

    <div class="container">
        <!-- Subnet Calculator Section -->
        <div class="section">
            <div class="section-title">subnet calculator</div>
            
            <div class="form-group">
                <label for="ipAddress">ipv4 or ipv6 address / cidr</label>
                <div class="input-row">
                    <input type="text" id="ipAddress" placeholder="e.g., 192.168.1.0/24 or 192.168.1.0 or 2001:db8:1::1 or 2001:db8:1::1/64">
                    <select id="subnetMask">
                        <option value="">select mask (optional)</option>
                        <option value="32">/32 - 255.255.255.255</option>
                        <option value="31">/31 - 255.255.255.254</option>
                        <option value="30">/30 - 255.255.255.252</option>
                        <option value="29">/29 - 255.255.255.248</option>
                        <option value="28">/28 - 255.255.255.240</option>
                        <option value="27">/27 - 255.255.255.224</option>
                        <option value="26">/26 - 255.255.255.192</option>
                        <option value="25">/25 - 255.255.255.128</option>
                        <option value="24">/24 - 255.255.255.0</option>
                        <option value="23">/23 - 255.255.254.0</option>
                        <option value="22">/22 - 255.255.252.0</option>
                        <option value="21">/21 - 255.255.248.0</option>
                        <option value="20">/20 - 255.255.240.0</option>
                        <option value="19">/19 - 255.255.224.0</option>
                        <option value="18">/18 - 255.255.192.0</option>
                        <option value="17">/17 - 255.255.128.0</option>
                        <option value="16">/16 - 255.255.0.0</option>
                        <option value="15">/15 - 255.254.0.0</option>
                        <option value="14">/14 - 255.252.0.0</option>
                        <option value="13">/13 - 255.248.0.0</option>
                        <option value="12">/12 - 255.240.0.0</option>
                        <option value="11">/11 - 255.224.0.0</option>
                        <option value="10">/10 - 255.192.0.0</option>
                        <option value="9">/9 - 255.128.0.0</option>
                        <option value="8">/8 - 255.0.0.0</option>
                    </select>
                    <button class="btn" onclick="calcSubnet()">calculate</button>
                </div>
            </div>

            <div id="subnetError" class="error" style="display: none;"></div>
            
            <div id="subnetResults" class="results" style="display: none;"></div>

<div class="input-row-two" id="copySubnetBtnContainer" style="display:none;">
  <button class="btn" id="copySubnetBtn" onclick="copyAllSubnetResults()">copy all results</button>
</div>

            <div class="clear-link">
                <a onclick="clearSubnet()">clear all values</a>
            </div>
        </div>

        <div class="divider"></div>

<!-- CIDR Calculator -->
<section id="cidr-section" class="calc-section">
  <div class="section-title">CIDR Range Calculator</div>

  <div class="form-group">
    <label for="startIp">Start IP Address</label>
    <input type="text" id="startIp" placeholder="e.g., 192.168.0.0" />
  </div>

  <div class="form-group">
    <label for="endIp">End IP Address</label>
    <input type="text" id="endIp" placeholder="e.g., 192.168.0.255" /></div>

      <div><button class="btn" onclick="calcCIDR()">calculate</button></div>
      
  <!-- <div class="button-row">
    <button class="primary-btn" onclick="calcCIDR()">Calculate</button>
    <button class="clear-btn" onclick="clearCIDR()">Clear All Values</button>
  </div> -->

  <div id="cidrError" class="error-message" style="display:none;"></div>

  <div id="cidrResults" class="results-card" style="display:none;">
      <div id="cidrOutput">
  <div class="info-section" id="cidrInfoSection" style="display:none;">
    <strong>cidr results</strong>
    <p id="cidrInfoText"></p>
  </div>
</div>      
  </div>
 <div class="clear-link">
                <a onclick="clearCIDR()">clear all values</a>
            </div>
</section>

        <div class="info-section">
            <strong>about these calculators</strong>
            <p><strong>subnet calculator:</strong> takes a network address in CIDR notation (like 192.168.1.0/24) and calculates important network information including the network address, broadcast address, subnet mask, and the range of usable IP addresses. the prefix length determines how many IP addresses are in the subnet.</p>
            <p><strong>cidr calculator:</strong> converts IP address ranges to CIDR notation. CIDR (classless inter-domain routing) is a compact method for specifying IP address ranges. it consists of an IP address followed by a slash and a number (the prefix length), such as 192.168.1.0/24.</p>
        </div>
    </div>

    <div id="toast" class="toast"></div>

    <script>
        // Utility functions
        function ipToInt(ip) {
            const parts = ip.split('.').map(Number);
            return (parts[0] << 24) + (parts[1] << 16) + (parts[2] << 8) + parts[3];
        }

        function intToIp(int) {
            return [
                (int >>> 24) & 0xFF,
                (int >>> 16) & 0xFF,
                (int >>> 8) & 0xFF,
                int & 0xFF
            ].join('.');
        }

        function intToHex(int) {
            return [
                ((int >>> 24) & 0xFF).toString(16).toUpperCase().padStart(2, '0'),
                ((int >>> 16) & 0xFF).toString(16).toUpperCase().padStart(2, '0'),
                ((int >>> 8) & 0xFF).toString(16).toUpperCase().padStart(2, '0'),
                (int & 0xFF).toString(16).toUpperCase().padStart(2, '0')
            ].join('.');
        }

        function ipToBinary(ip) {
            const parts = ip.split('.');
            return parts.map(part => {
                return parseInt(part).toString(2).padStart(8, '0');
            }).join('.');
        }

        function isValidIp(ip) {
            const parts = ip.split('.');
            if (parts.length !== 4) return false;
            return parts.every(part => {
                const num = Number(part);
                return num >= 0 && num <= 255 && part === num.toString();
            });
        }

        function getNetworkClass(firstOctet) {
            if (firstOctet >= 1 && firstOctet <= 126) return 'A';
            if (firstOctet >= 128 && firstOctet <= 191) return 'B';
            if (firstOctet >= 192 && firstOctet <= 223) return 'C';
            if (firstOctet >= 224 && firstOctet <= 239) return 'D (multicast)';
            if (firstOctet >= 240 && firstOctet <= 255) return 'E (reserved)';
            return 'unknown';
        }

        function isPrivateIp(ip) {
            const parts = ip.split('.').map(Number);
            if (parts[0] === 10) return true;
            if (parts[0] === 172 && parts[1] >= 16 && parts[1] <= 31) return true;
            if (parts[0] === 192 && parts[1] === 168) return true;
            return false;
        }

        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).then(() => {
                showToast('copied to clipboard');
            }).catch(err => {
                showToast('failed to copy');
            });
        }

        function showToast(message) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => {
                toast.classList.remove('show');
            }, 2000);
        }

// SUBNET CALCULATOR - Updated to handle both IPv4 and IPv6
function calcSubnet() {
    const input = document.getElementById('ipAddress').value.trim();
    const maskSelect = document.getElementById('subnetMask').value;
    const errorDiv = document.getElementById('subnetError');
    const resultsDiv = document.getElementById('subnetResults');

    errorDiv.style.display = 'none';
    resultsDiv.style.display = 'none';

    let ip, prefix;
    if (input.includes('/')) {
        const parts = input.split('/');
        ip = parts[0];
        prefix = parseInt(parts[1]);
    } else {
        ip = input;
        if (maskSelect) {
            prefix = parseInt(maskSelect);
        } else {
            showSubnetError('Please provide a CIDR prefix (e.g., /24 or /64) or select a subnet mask.');
            return;
        }
    }

    if (ip.includes('.')) {
        // --- IPv4 Logic ---
        if (!isValidIpV4(ip)) {
            showSubnetError('Invalid IPv4 address format.');
            return;
        }
        if (isNaN(prefix) || prefix < 0 || prefix > 32) {
            showSubnetError('Invalid IPv4 CIDR prefix (must be between 0 and 32).');
            return;
        }
        calcSubnetV4(ip, prefix); // Existing logic is moved into a new function
    } else if (ip.includes(':')) {
        // --- IPv6 Logic ---
        if (!isValidIpV6(ip)) {
            showSubnetError('Invalid IPv6 address format.');
            return;
        }
        if (isNaN(prefix) || prefix < 0 || prefix > 128) {
            showSubnetError('Invalid IPv6 CIDR prefix (must be between 0 and 128).');
            return;
        }
        calcSubnetV6(ip, prefix); // New IPv6 logic
    } else {
        showSubnetError('Invalid IP address format. Must be IPv4 (e.g., 192.0.2.1) or IPv6 (e.g., 2001:db8::1).');
        return;
    }
    document.getElementById('copySubnetBtnContainer').style.display = 'block';
}

        // Original IPv4 calculation logic
function calcSubnetV4(ip, prefix) {
    const ipInt = ipToInt(ip);
    const maskInt = (0xFFFFFFFF << (32 - prefix)) >>> 0;
    const networkInt = (ipInt & maskInt) >>> 0;
    const broadcastInt = (networkInt | ~maskInt) >>> 0;
    
    // ... (rest of your original IPv4 logic) ...
    const totalHosts = Math.pow(2, 32 - prefix);
    const usableHosts = prefix === 32 ? 1 : (prefix === 31 ? 2 : totalHosts - 2);
    
    const networkIp = intToIp(networkInt);
    const broadcastIp = intToIp(broadcastInt);
    const subnetMask = intToIp(maskInt);
    const wildcardMask = intToIp((~maskInt) >>> 0);
    
    const firstUsableIp = prefix === 32 ? networkIp : (prefix === 31 ? networkIp : intToIp(networkInt + 1));
    const lastUsableIp = prefix === 32 ? networkIp : (prefix === 31 ? broadcastIp : intToIp(broadcastInt - 1));
    
    const ipClass = getNetworkClass(parseInt(ip.split('.')[0]));
    const isPrivate = isPrivateIp(networkIp);

    const inputHex = intToHex(ipInt);
    const networkHex = intToHex(networkInt);
    const broadcastHex = intToHex(broadcastInt);
    const maskHex = intToHex(maskInt);

    displaySubnetResults({
        // ... (all your original data objects) ...
        inputIp: ip,
        inputCidr: networkIp + '/' + prefix,
        inputLong: ipInt >>> 0,
        inputHex: inputHex,
        cidr: networkIp + '/' + prefix,
        cidrIpRange: networkIp + ' - ' + broadcastIp,
        cidrLongRange: (networkInt >>> 0) + ' - ' + (broadcastInt >>> 0),
        cidrHexRange: networkHex + ' - ' + broadcastHex,
        ipsInRange: totalHosts,
        maskBits: prefix,
        subnetMask: subnetMask,
        hexSubnetMask: maskHex,
        networkAddress: networkIp,
        broadcastAddress: broadcastIp,
        wildcardMask: wildcardMask,
        firstUsable: firstUsableIp,
        lastUsable: lastUsableIp,
        usableHosts: usableHosts,
        ipClass: ipClass,
        isPrivate: isPrivate,
        networkBinary: ipToBinary(networkIp),
        maskBinary: ipToBinary(subnetMask),
        version: 'IPv4' // Added version for display
    });
}

// New IPv6 calculation logic
function calcSubnetV6(ip, prefix) {
    // 1. Convert the (potentially compressed) IPv6 address to a full 128-bit BigInt
    const ipBigInt = ipv6ToBigInt(ip);

    // 2. Create the network mask (prefix '1's followed by '0's)
    // The mask is 128 bits long. We shift a 1 to the 'prefix' position, subtract 1,
    // and then invert the result relative to 128 bits to get the ones/zeroes in the right order.
    // However, it's easier to create the mask of '1's directly:
    const maskShift = 128n - BigInt(prefix);
    const allOnes = (1n << 128n) - 1n; // 128 ones
    
    // Create a block of (128 - prefix) zeroes at the end
    const hostPartMask = (1n << maskShift) - 1n; // The mask for the host part (trailing zeroes)
    const networkMaskBigInt = allOnes ^ hostPartMask; // The mask for the network part (leading ones)

    // 3. Calculate Network Address
    const networkBigInt = ipBigInt & networkMaskBigInt;

    // 4. Calculate Broadcast/Last Address
    // In IPv6, the "broadcast" address is the last address in the subnet (the network address OR-ed with the host part mask).
    const broadcastBigInt = networkBigInt | hostPartMask;

    // 5. Convert results back to standard IPv6 string notation
    const networkAddress = bigIntToIpv6(networkBigInt);
    const broadcastAddress = bigIntToIpv6(broadcastBigInt);
    const networkMaskStr = bigIntToIpv6(networkMaskBigInt); // The 'mask' in its full format

    // 6. Calculate Hosts
    // The number of addresses is 2^(128 - prefix). This is a very large number, so we display it as a power of 2.
    const ipsInRange = `2^${128 - prefix}`; // Display as power of 2
    const usableHosts = ipsInRange; // All addresses are usable in IPv6 (no reserved network/broadcast)

    // 7. First/Last Usable IP
    const firstUsable = networkAddress; // All IPs are usable, including network address
    const lastUsable = broadcastAddress;

    // 8. Prepare for display (using simplified presentation for IPv6)
    displaySubnetResults({
        inputIp: ip,
        inputCidr: networkAddress + '/' + prefix,
        inputLong: 'N/A (Too Large)',
        inputHex: bigIntToHex(ipBigInt, 32),
        cidr: networkAddress + '/' + prefix,
        cidrIpRange: networkAddress + ' - ' + broadcastAddress,
        cidrLongRange: 'N/A',
        cidrHexRange: bigIntToHex(networkBigInt, 32) + ' - ' + bigIntToHex(broadcastBigInt, 32),
        ipsInRange: ipsInRange,
        maskBits: prefix,
        subnetMask: networkMaskStr, // Note: IPv6 rarely uses mask notation, but we calculate it.
        hexSubnetMask: bigIntToHex(networkMaskBigInt, 32),
        networkAddress: networkAddress,
        broadcastAddress: broadcastAddress,
        wildcardMask: 'N/A (Not Applicable)', // Not commonly used in IPv6
        firstUsable: firstUsable,
        lastUsable: lastUsable,
        usableHosts: usableHosts,
        ipClass: 'N/A (No Class)',
        isPrivate: isPrivateIpv6(networkAddress) ? 'Private (Unique Local)' : 'Public/Global',
        networkBinary: 'N/A (Too Long)',
        maskBinary: 'N/A (Too Long)',
        version: 'IPv6'
    });
}

        // Helper to check for basic valid IPv4 format
function isValidIpV4(ip) {
    return /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(ip);
}

// Basic check for IPv6 (just looks for colons, relies on the BigInt parser for stricter validation)
function isValidIpV6(ip) {
    return /:/.test(ip);
}

// Convert a full or compressed IPv6 string to a 128-bit BigInt
function ipv6ToBigInt(ip) {
    let canonical = ip.toLowerCase();
    
    // Simple decompression of '::'
    if (canonical.includes('::')) {
        const parts = canonical.split('::');
        const leftParts = parts[0] ? parts[0].split(':') : [];
        const rightParts = parts[1] ? parts[1].split(':') : [];
        const missing = 8 - leftParts.length - rightParts.length;
        const padding = Array(missing).fill('0000');
        canonical = leftParts.join(':') + ':' + padding.join(':') + (rightParts.length ? ':' : '') + rightParts.join(':');
    }
    
    // Ensure 8 parts (padding needed for non-compressed addresses like 2001:db8:0:0:0:0:0:1)
    if (!canonical.includes('::') && canonical.split(':').length < 8) {
        canonical = canonical.split(':').map(part => part.padStart(4, '0')).join(':');
    }

    let ipBigInt = 0n;
    const segments = canonical.split(':');

    // Handle embedded IPv4
    if (segments.length === 8 && segments[7].includes('.')) {
        segments[7] = segments[7].split('.').map(o => parseInt(o).toString(16).padStart(2, '0')).join('');
        segments.pop(); // Remove the single mixed segment
        segments.push(segments[7].substring(0, 4));
        segments.push(segments[7].substring(4, 8));
    }
    
    // Pad all segments to 4 chars and concatenate for hex string
    let hex = segments.map(seg => seg.padStart(4, '0')).join('');
    if (hex.length === 32) {
        ipBigInt = BigInt(`0x${hex}`);
    } else {
        // Fallback for tricky input, use 0n
        return 0n; 
    }

    return ipBigInt;
}

// Convert a 128-bit BigInt back to a compressed IPv6 string
function bigIntToIpv6(bigInt) {
    let hex = bigInt.toString(16).padStart(32, '0');
    let segments = [];
    for (let i = 0; i < 32; i += 4) {
        segments.push(hex.substring(i, i + 4));
    }
    
    // Pad segments and remove leading zeros
    segments = segments.map(s => s.replace(/^0+/, '') || '0');

    // Recompress '::' - Find the longest run of '0' segments
    let ipStr = segments.join(':');
    ipStr = ipStr.replace(/(:0){2,}/, '::');
    
    return ipStr;
}

// Convert BigInt to a hexadecimal string of a specified length
function bigIntToHex(bigInt, length) {
    return bigInt.toString(16).padStart(length, '0').toUpperCase();
}

// Basic check for Unique Local Address (ULA) in IPv6
function isPrivateIpv6(ip) {
    // Unique Local Addresses start with 'fd'
    return ip.toLowerCase().startsWith('fd');
}

// NOTE: You'll also need to update your `displaySubnetResults` 
// and `createResultItem/Box` functions to conditionally handle the 'N/A' 
// or large number formats for IPv6, as shown in the `calcSubnetV6` call.

// Original IPv4 Helper functions (ensure these are available)
// function ipToInt(ip) { ... }
// function intToIp(ipInt) { ... }
// function intToHex(ipInt) { ... }
// function ipToBinary(ip) { ... }
// function getNetworkClass(firstOctet) { ... }
// function isPrivateIp(ip) { ... }
// function showSubnetError(message) { ... }
// function displaySubnetResults(data) { ... }
        function displaySubnetResults(data) {
            const resultsDiv = document.getElementById('subnetResults');
            
            let html = '<div class="result-grid">';
            html += createResultBox('input', data.inputCidr);
            html += createResultBox('input ip', data.inputIp);
            html += createResultBox('input long', data.inputLong);
            html += createResultBox('input hex', data.inputHex);
            html += '</div><div class="result-grid">';
            html += createResultBox('cidr', data.cidr);
            html += createResultBox('cidr ip range', data.cidrIpRange);
            html += createResultBox('cidr long range', data.cidrLongRange);
            html += createResultBox('cidr hex range', data.cidrHexRange);
            html += '</div><div class="result-grid">';
            html += createResultBox('ips in range', data.ipsInRange.toLocaleString());
            html += createResultBox('mask bits', data.maskBits);
            html += createResultBox('subnet mask', data.subnetMask);
            html += createResultBox('hex subnet mask', data.hexSubnetMask);
            html += '</div>';

            html += '<div class="result-section">';
            html += '<h3>network information</h3>';
            html += createResultItem('network address', data.networkAddress);
            html += createResultItem('broadcast address', data.broadcastAddress);
            html += createResultItem('wildcard mask', data.wildcardMask);
            html += '</div>';

            html += '<div class="result-section">';
            html += '<h3>usable ip range</h3>';
            html += createResultItem('first usable ip', data.firstUsable);
            html += createResultItem('last usable ip', data.lastUsable);
            html += createResultItem('usable ip addresses', data.usableHosts.toLocaleString(), false);
            html += '</div>';

            html += '<div class="result-section">';
            html += '<h3>additional information</h3>';
            html += createResultItem('ip class', data.ipClass, false);
            html += createResultItem('ip type', data.isPrivate ? 'private' : 'public', false);
            html += '<div class="result-item" style="flex-direction: column; align-items: flex-start;">';
            html += '<span class="result-label">binary subnet mask</span>';
            html += '<span class="subnet-binary">' + data.maskBinary + '</span>';
            html += '</div>';
            html += '<div class="result-item" style="flex-direction: column; align-items: flex-start;">';
            html += '<span class="result-label">network address (binary)</span>';
            html += '<span class="subnet-binary">' + data.networkBinary + '</span>';
            html += '</div>';
            html += '</div>';

            resultsDiv.innerHTML = html;
            resultsDiv.style.display = 'block';
        }

  function createResultBox(label, value) {
    // 1. Stringify the value for safe use within the onclick attribute
    const safeValue = JSON.stringify(String(value)); 

    let html = '<div class="result-box">';
    html += '<div class="result-box-label">' + label + '</div>';
    html += '<div class="result-box-value">';
    html += '<span>' + value + '</span>';
    // 2. Use safeValue in the onclick handler instead of the complex String(value).replace()
    html += '<button class="copy-btn" onclick="copyToClipboard(' + safeValue + ')" title="copy to clipboard">';
    html += '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">';
    html += '<rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>';
    html += '<path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>';
    html += '</svg></button>';
    html += '</div></div>';
    return html;
}

function createResultItem(label, value, showCopy = true) {
    let html = '<div class="result-item">';
    html += '<span class="result-label">' + label + '</span>';
    html += '<span class="result-value">' + value;
    if (showCopy) {
        // 1. Stringify the value for safe use within the onclick attribute
        const safeValue = JSON.stringify(String(value));
        
        // 2. Use safeValue in the onclick handler
        html += '<button class="copy-btn" onclick="copyToClipboard(' + safeValue + ')" title="copy to clipboard">';
        html += '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">';
        html += '<rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>';
        html += '<path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>';
        html += '</svg></button>';
    }
    html += '</span></div>';
    return html;
}

        function showSubnetError(message) {
            const errorDiv = document.getElementById('subnetError');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }

        function clearSubnet() {
            document.getElementById('ipAddress').value = '';
            document.getElementById('subnetMask').value = '';
            document.getElementById('subnetError').style.display = 'none';
            document.getElementById('subnetResults').style.display = 'none';
            document.getElementById('copySubnetBtnContainer').style.display = 'none';
        }

// ---- CIDR Calculator ---- //

function calcCIDR() {
  const startIp = document.getElementById('startIp').value.trim();
  const endIp = document.getElementById('endIp').value.trim();
  const errorDiv = document.getElementById('cidrError');
  const resultsDiv = document.getElementById('cidrResults');
  const outputDiv = document.getElementById('cidrOutput');

  errorDiv.style.display = 'none';
  resultsDiv.style.display = 'none';

  if (!validateIP(startIp) || !validateIP(endIp)) {
    showCIDRError('Please enter valid IPv4 addresses.');
    return;
  }

  const start = ipToLong(startIp);
  const end = ipToLong(endIp);

  if (end < start) {
    showCIDRError('End IP must be greater than or equal to Start IP.');
    return;
  }

  const blocks = calculateCIDRBlocks(start, end);
  
const infoSection = document.getElementById('cidrInfoSection');
const infoText = document.getElementById('cidrInfoText');

infoText.innerHTML = blocks.join('<br>');
infoSection.style.display = 'block';
    
  resultsDiv.style.display = 'block';
}

function calculateCIDRBlocks(start, end) {
  const result = [];
  while (end >= start) {
    // Largest power of two block that fits starting from 'start'
    let maxSize = 32;
    while (maxSize > 0) {
      const mask = 2 ** (32 - maxSize);
      if ((start & (mask - 1)) !== 0) break;
      maxSize--;
    }

    // Largest block that does not exceed the end IP
    const remaining = end - start + 1;
    while (2 ** (32 - maxSize) > remaining) maxSize++;

    result.push(longToIP(start) + '/' + maxSize);
    start += 2 ** (32 - maxSize);
  }
  return result;
}

function validateIP(ip) {
  const parts = ip.split('.');
  if (parts.length !== 4) return false;
  return parts.every(p => p >= 0 && p <= 255 && /^\d+$/.test(p));
}

function ipToLong(ip) {
  return ip.split('.').reduce((acc, oct) => (acc << 8) + parseInt(oct), 0) >>> 0;
}

function longToIP(long) {
  return [
    (long >>> 24) & 255,
    (long >>> 16) & 255,
    (long >>> 8) & 255,
    long & 255
  ].join('.');
}

function showCIDRError(message) {
  const errorDiv = document.getElementById('cidrError');
  errorDiv.textContent = message;
  errorDiv.style.display = 'block';
}

function clearCIDR() {
  document.getElementById('startIp').value = '';
  document.getElementById('endIp').value = '';
  document.getElementById('cidrError').style.display = 'none';
  document.getElementById('cidrResults').style.display = 'none';
}
        // Enter key support
        document.getElementById('ipAddress').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') calcSubnet();
        });
        document.getElementById('startIp').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') calcCIDR();
        });
        document.getElementById('endIp').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') calcCIDR();
        });

function copyAllSubnetResults() {
    const resultsDiv = document.getElementById('subnetResults');
    if (!resultsDiv || resultsDiv.style.display === 'none') {
        alert('No subnet results to copy.');
        return;
    }

    let output = '';

    // === Timestamp & Input Summary ===
    const now = new Date();
    const timestamp = now.toLocaleString();

    // Try to detect the CIDR input (IPv4 or IPv6)
    const cidrItem = [...resultsDiv.querySelectorAll('.result-box, .result-item')]
        .find(el => el.innerText.includes('/') && el.innerText.match(/[\dA-Fa-f:.]+\/\d+/));
    const inputSummary = cidrItem
        ? (cidrItem.innerText.split(':')[1]?.trim() || cidrItem.innerText.trim())
        : '';

    // IPv6 detection (simple heuristic)
    const isIPv6 = inputSummary.includes(':');

    output += `Subnet Calculation Results\n`;
    output += `Generated on: ${timestamp}\n`;
    if (inputSummary) output += `Input: ${inputSummary}\n`;
    output += `Type: ${isIPv6 ? 'IPv6' : 'IPv4'}\n\n`;

    // === Collect result sections ===
    const sections = resultsDiv.querySelectorAll('.result-section, .result-grid');

    sections.forEach(section => {
        const header = section.querySelector('h3');
        if (header) {
            // Adjust certain section names dynamically
            let title = header.innerText.trim();
            if (isIPv6 && title.toLowerCase().includes('network information')) {
                title = 'Network Prefix Information';
            } else if (isIPv6 && title.toLowerCase().includes('usable ip range')) {
                title = 'Assignable Address Range';
            }

            const line = '='.repeat(title.length);
            output += `${title.toUpperCase()}\n${line}\n`;
        }

        const items = section.querySelectorAll('.result-item, .result-box');
        items.forEach(item => {
            const label = item.querySelector('.result-label, .result-box-label')?.innerText?.trim() || '';
            const value = item.querySelector('.result-value, .result-box-value span')?.innerText?.trim() || '';
            if (label && value) {
                // For IPv6, rename certain fields for clarity
                let adjustedLabel = label;
                if (isIPv6) {
                    if (label.toLowerCase().includes('network address')) adjustedLabel = 'network prefix';
                    if (label.toLowerCase().includes('broadcast')) adjustedLabel = 'last address in prefix';
                    if (label.toLowerCase().includes('subnet mask')) adjustedLabel = 'prefix length';
                    if (label.toLowerCase().includes('wildcard mask')) adjustedLabel = 'prefix mask (not used)';
                }
                output += `${adjustedLabel}: ${value}\n`;
            }
        });

        output += '\n';
    });

    // === Decode if URI-encoded ===
    if (/%[0-9A-F]{2}/i.test(output)) {
        try {
            output = decodeURIComponent(output);
        } catch (e) {
            console.warn('Skipping decode â€” invalid URI encoding.');
        }
    }

    // === Copy to clipboard ===
    navigator.clipboard.writeText(output).then(() => {
        showToast('All subnet results copied to clipboard.');
    }).catch(err => {
        console.error('Copy failed', err);
        showToast('Unable to copy results.');
    });
}

        
        
    </script>
</body>
</html>
        // Dark mode toggle
        function toggleTheme() {
            document.body.classList.toggle('dark-mode');
            localStorage.setItem('theme', document.body.classList.contains('dark-mode') ? 'dark' : 'light');
        }

        // Load saved theme preference
        if (localStorage.getItem('theme') === 'dark') {
            document.body.classList.add('dark-mode');
        }
    </script>
</body>
</html>
